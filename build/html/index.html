<!DOCTYPE html>

<html lang="Python" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Welcome to Lfepy’s documentation! &#8212; lfepy 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=c058f7c8" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=afdf7161"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="welcome-to-lfepys-documentation">
<h1>Welcome to Lfepy’s documentation!<a class="headerlink" href="#welcome-to-lfepys-documentation" title="Link to this heading">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<dl class="py function" id="module-lfepy.Descriptor.BPPC">
<dt class="sig sig-object py" id="lfepy.Descriptor.BPPC.BPPC">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.BPPC.</span></span><span class="sig-name descname"><span class="pre">BPPC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.BPPC.BPPC" title="Link to this definition">¶</a></dt>
<dd><p>Compute Binary Phase Pattern Concatenation (BPPC) histograms and descriptors from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing BPPC extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>BPPC_hist: Histogram(s) of BPPC descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing BPPC descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">BPPC</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>S. Shojaeilangari, W.-Y. Yau, J. Li, and E.-K. Teoh,
Feature extraction through binary pattern of phase congruency for facial expression recognition,
Control Automation Robotics &amp; Vision (ICARCV), 2012 12th International Conference on,
IEEE, 2012, pp. 166-170.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.GDP">
<dt class="sig sig-object py" id="lfepy.Descriptor.GDP.GDP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.GDP.</span></span><span class="sig-name descname"><span class="pre">GDP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.GDP.GDP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Gradient Directional Pattern (GDP) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing GDP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
<li><p><strong>kwargs.mask</strong> (<em>str</em>) -- Mask type for gradient computation. Options: 'sobel', 'prewitt'. Default: 'sobel'.</p></li>
<li><p><strong>kwargs.t</strong> (<em>float</em>) -- Threshold value for gradient angle difference. Default: 22.5.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>GDP_hist: Histogram(s) of GDP descriptors.</p></li>
<li><p>imgDesc: GDP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">GDP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;sobel&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">22.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>F. Ahmed,
Gradient directional pattern: a robust feature descriptor for facial expression recognition.
Electronics letters 48 (2012) 1203-1204.</p>
<p>W. Chu,
Facial expression recognition based on local binary pattern and gradient directional pattern,
Green Computing and Communications (GreenCom), 2013 IEEE and Internet of Things (iThings/CPSCom),
IEEE International Conference on and IEEE Cyber, Physical and Social Computing,
IEEE, 2013, pp. 1458-1462.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.GDP2">
<dt class="sig sig-object py" id="lfepy.Descriptor.GDP2.GDP2">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.GDP2.</span></span><span class="sig-name descname"><span class="pre">GDP2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.GDP2.GDP2" title="Link to this definition">¶</a></dt>
<dd><p>Compute Gradient Direction Pattern (GDP2) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing GDP2 extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>GDP2_hist: Histogram(s) of GDP2 descriptors.</p></li>
<li><p>imgDesc: GDP2 descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">GDP2</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>M.S. Islam,
Gender Classification using Gradient Direction Pattern.
Science International 25 (2013).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.GLTP">
<dt class="sig sig-object py" id="lfepy.Descriptor.GLTP.GLTP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.GLTP.</span></span><span class="sig-name descname"><span class="pre">GLTP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.GLTP.GLTP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Gradient-based Local Ternary Pattern (GLTP) histograms and descriptors from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing GLTP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
<li><p><strong>kwargs.t</strong> (<em>int</em>) -- Threshold value for ternary pattern computation. Default: 10.</p></li>
<li><p><strong>kwargs.DGLP</strong> (<em>int</em>) -- Flag to include Directional Gradient-based Local Pattern. If set to 1, includes DGLP. Default: 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>GLTP_hist: Histogram(s) of GLTP descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing GLTP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">GLTP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">DGLP</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>M. Valstar, and M. Pantic,
Fully automatic facial action unit detection and temporal analysis,
Computer Vision and Pattern Recognition Workshop, 2006. CVPRW'06. Conference on,
IEEE, 2006, pp. 149-149.</p>
<p>F. Ahmed, and E. Hossain,
Automated facial expression recognition using gradient-based ternary texture patterns.
Chinese Journal of Engineering 2013 (2013).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.IWBC">
<dt class="sig sig-object py" id="lfepy.Descriptor.IWBC.IWBC">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.IWBC.</span></span><span class="sig-name descname"><span class="pre">IWBC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.IWBC.IWBC" title="Link to this definition">¶</a></dt>
<dd><p>Compute Improved Weber Contrast (IWBC) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing IWBC extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
<li><p><strong>kwargs.scale</strong> (<em>int</em>) -- Scale factor for IWBC computation. Default: 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>IWBC_hist: Histogram(s) of IWBC descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing IWBC descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">IWBC</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>B.-Q. Yang, T. Zhang, C.-C. Gu, K.-J. Wu, and X.-P. Guan,
A novel face recognition method based on iwld and iwbc.
Multimedia Tools and Applications 75 (2016) 6979.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LAP">
<dt class="sig sig-object py" id="lfepy.Descriptor.LAP.LAP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LAP.</span></span><span class="sig-name descname"><span class="pre">LAP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LAP.LAP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Arc Pattern (LAP) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LAP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LAP_hist: Histogram(s) of LAP descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing LAP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LAP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>M.S. Islam, and S. Auwatanamongkol,
Facial Expression Recognition using Local Arc Pattern.
Trends in Applied Sciences Research 9 (2014) 113.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LBP">
<dt class="sig sig-object py" id="lfepy.Descriptor.LBP.LBP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LBP.</span></span><span class="sig-name descname"><span class="pre">LBP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LBP.LBP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Binary Patterns (LBP) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LBP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
<li><p><strong>kwargs.radius</strong> (<em>int</em>) -- Radius for LBP computation. Default: 1.</p></li>
<li><p><strong>kwargs.mappingType</strong> (<em>str</em>) -- Type of mapping for LBP computation. Options: 'full', 'ri', 'u2', 'riu2'. Default: 'full'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LBP_hist: Histogram(s) of LBP descriptors.</p></li>
<li><p>imgDesc: LBP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LBP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mappingType</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>T. Ojala, M. Pietikainen, and T. Maenpaa,
Multi-resolution gray-scale and rotation invariant texture classification with local binary patterns.
IEEE Transactions on pattern analysis and machine intelligence 24 (2002) 971-987.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LDiP">
<dt class="sig sig-object py" id="lfepy.Descriptor.LDiP.LDiP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LDiP.</span></span><span class="sig-name descname"><span class="pre">LDiP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LDiP.LDiP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Directional Pattern (LDiP) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LDiP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LDiP_hist: Histogram(s) of LDiP descriptors.</p></li>
<li><p>imgDesc: LDiP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LDiP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>T. Jabid, M.H. Kabir, and O. Chae,
Local directional pattern (LDP)–A robust image descriptor for object recognition,
Advanced Video and Signal Based Surveillance (AVSS), 2010 Seventh IEEE International Conference on,
IEEE, 2010, pp. 482-487.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LDiPv">
<dt class="sig sig-object py" id="lfepy.Descriptor.LDiPv.LDiPv">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LDiPv.</span></span><span class="sig-name descname"><span class="pre">LDiPv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LDiPv.LDiPv" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Directional Pattern Variance (LDiPv) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LDiPv extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LDiPv_hist: Histogram(s) of LDiPv descriptors.</p></li>
<li><p>imgDesc: LDiPv descriptors themselves.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LDiPv</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>M.H. Kabir, T. Jabid, and O. Chae,
A local directional pattern variance (LDPv) based face descriptor for human facial expression recognition,
Advanced Video and Signal Based Surveillance (AVSS), 2010 Seventh IEEE International Conference on,
IEEE, 2010, pp. 526-532.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LDN">
<dt class="sig sig-object py" id="lfepy.Descriptor.LDN.LDN">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LDN.</span></span><span class="sig-name descname"><span class="pre">LDN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LDN.LDN" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Difference Number (LDN) histograms and descriptors from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LDN extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
<li><p><strong>kwargs.mask</strong> (<em>str</em>) -- Mask type for LDN computation. Options: 'gaussian', 'kirsch', 'sobel', or 'prewitt'. Default: 'kirsch'.</p></li>
<li><p><strong>kwargs.msize</strong> (<em>int</em>) -- Mask size if 'mask' is set to 'kirsch'. Default: 3.</p></li>
<li><p><strong>kwargs.start</strong> (<em>float</em>) -- Starting sigma value if 'mask' is set to 'gaussian'. Default: 0.5.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LDN_hist: Histogram(s) of LDN descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing LDN descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LDN</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;kirsch&#39;</span><span class="p">,</span> <span class="n">msize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>A.R. Rivera, J.R. Castillo, and O.O. Chae,
Local directional number pattern for face analysis: Face and expression recognition.
IEEE transactions on image processing 22 (2013) 1740-1752.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LDTP">
<dt class="sig sig-object py" id="lfepy.Descriptor.LDTP.LDTP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LDTP.</span></span><span class="sig-name descname"><span class="pre">LDTP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LDTP.LDTP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Directional Texture Pattern (LDTP) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LDTP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
<li><p><strong>kwargs.epsi</strong> (<em>int</em>) -- Threshold value for texture difference. Default: 15.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LDTP_hist: Histogram(s) of LDTP descriptors.</p></li>
<li><p>imgDesc: LDTP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LDTP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">epsi</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>A.R. Rivera, J.R. Castillo, and O. Chae,
Local directional texture pattern image descriptor.
Pattern Recognition Letters 51 (2015) 94-100.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LFD">
<dt class="sig sig-object py" id="lfepy.Descriptor.LFD.LFD">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LFD.</span></span><span class="sig-name descname"><span class="pre">LFD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LFD.LFD" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Frequency Descriptor (LFD) histograms and descriptors from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LFD extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LFD_hist: Histogram(s) of LFD descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing LFD descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LFD</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>Z. Lei, T. Ahonen, M. Pietikäinen, and S.Z. Li,
Local frequency descriptor for low-resolution face recognition,
Automatic Face &amp; Gesture Recognition and Workshops (FG 2011), 2011 IEEE International Conference on,
IEEE, 2011, pp. 161-166.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LGBPHS">
<dt class="sig sig-object py" id="lfepy.Descriptor.LGBPHS.LGBPHS">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LGBPHS.</span></span><span class="sig-name descname"><span class="pre">LGBPHS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LGBPHS.LGBPHS" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Gabor Binary Pattern Histogram Sequence (LGBPHS) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LGBPHS extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
<li><p><strong>kwargs.uniformLBP</strong> (<em>int</em>) -- Flag to use uniform LBP. Default: 1 (use uniform LBP).</p></li>
<li><p><strong>kwargs.scaleNum</strong> (<em>int</em>) -- Number of scales for Gabor filters. Default: 5.</p></li>
<li><p><strong>kwargs.orienNum</strong> (<em>int</em>) -- Number of orientations for Gabor filters. Default: 8.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LGBPHS_hist: Histogram(s) of LGBPHS descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing LGBPHS descriptors for each scale and orientation.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LGBPHS</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">uniformLBP</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">scaleNum</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">orienNum</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>W. Zhang, S. Shan, W. Gao, X. Chen, and H. Zhang,
Local gabor binary pattern histogram sequence (lgbphs): A novel non-statistical model for face representation and recognition,
Computer Vision, 2005. ICCV 2005. Tenth IEEE International Conference on,
IEEE, 2005, pp. 786-791.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LGDiP">
<dt class="sig sig-object py" id="lfepy.Descriptor.LGDiP.LGDiP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LGDiP.</span></span><span class="sig-name descname"><span class="pre">LGDiP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LGDiP.LGDiP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Gabor Directional Pattern (LGDiP) histograms and descriptors from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LGDiP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LGDiP_hist: Histogram(s) of LGDiP descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing LGDiP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LGDiP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>S.Z. Ishraque, A.H. Banna, and O. Chae,
Local Gabor directional pattern for facial expression recognition,
Computer and Information Technology (ICCIT), 2012 15th International Conference on,
IEEE, 2012, pp. 164-167.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LGIP">
<dt class="sig sig-object py" id="lfepy.Descriptor.LGIP.LGIP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LGIP.</span></span><span class="sig-name descname"><span class="pre">LGIP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LGIP.LGIP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Gradient Increasing Pattern (LGIP) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LGIP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LGIP_hist: Histogram(s) of LGIP descriptors.</p></li>
<li><p>imgDesc: LGIP descriptors themselves.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LGIP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>Z. Lubing, and W. Han,
Local gradient increasing pattern for facial expression recognition,
Image Processing (ICIP), 2012 19th IEEE International Conference on,
IEEE, 2012, pp. 2601-2604.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LGP">
<dt class="sig sig-object py" id="lfepy.Descriptor.LGP.LGP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LGP.</span></span><span class="sig-name descname"><span class="pre">LGP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LGP.LGP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Gradient Pattern (LGP) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LGP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LGP_hist: Histogram(s) of LGP descriptors.</p></li>
<li><p>imgDesc: LGP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LGP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>M.S. Islam,
Local gradient pattern-A novel feature representation for facial expression recognition,
Journal of AI and Data Mining 2 (2014) 33-38.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LGTrP">
<dt class="sig sig-object py" id="lfepy.Descriptor.LGTrP.LGTrP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LGTrP.</span></span><span class="sig-name descname"><span class="pre">LGTrP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LGTrP.LGTrP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Gabor Transitional Pattern (LGTrP) histograms and descriptors from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LGTrP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LGTrP_hist: Histogram(s) of LGTrP descriptors.</p></li>
<li><p>imgDesc: LGTrP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LGTrP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>M.S. Islam,
Local gradient pattern-A novel feature representation for facial expression recognition,
Journal of AI and Data Mining 2 (2014) 33-38.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LMP">
<dt class="sig sig-object py" id="lfepy.Descriptor.LMP.LMP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LMP.</span></span><span class="sig-name descname"><span class="pre">LMP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LMP.LMP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Monotonic Pattern (LMP) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LMP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LMP_hist: Histogram(s) of LMP descriptors.</p></li>
<li><p>imgDesc: LMP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LMP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>T. Mohammad, and M.L. Ali,
Robust facial expression recognition based on local monotonic pattern (LMP),
Computer and Information Technology (ICCIT), 2011 14th International Conference on,
IEEE, 2011, pp. 572-576.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LPQ">
<dt class="sig sig-object py" id="lfepy.Descriptor.LPQ.LPQ">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LPQ.</span></span><span class="sig-name descname"><span class="pre">LPQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LPQ.LPQ" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Phase Quantization (LPQ) histograms and descriptors from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LPQ extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
<li><p><strong>kwargs.windowSize</strong> (<em>int</em>) -- Size of the sliding window for LPQ. Default: 5.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LPQ_hist: Histogram of LPQ descriptors.</p></li>
<li><p>imgDesc: LPQ descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LPQ</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">windowSize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>V. Ojansivu, and J. Heikkilä,
Blur insensitive texture classification using local phase quantization,
International conference on image and signal processing,
Springer, 2008, pp. 236-243.</p>
<p>A. Dhall, A. Asthana, R. Goecke, and T. Gedeon,
Emotion recognition using PHOG and LPQ features,
Automatic Face &amp; Gesture Recognition and Workshops (FG 2011), 2011 IEEE International Conference on,
IEEE, 2011, pp. 878-883.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LTeP">
<dt class="sig sig-object py" id="lfepy.Descriptor.LTeP.LTeP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LTeP.</span></span><span class="sig-name descname"><span class="pre">LTeP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LTeP.LTeP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Ternary Pattern (LTeP) histograms and descriptors from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LTeP extraction.</p></li>
<li><p><strong>kwargs.t</strong> (<em>int</em>) -- Threshold value for ternary pattern computation. Default: 2.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LTeP_hist: Histogram(s) of LTeP descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing LTeP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LTeP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>F. Bashar, A. Khan, F. Ahmed, and M.H. Kabir,
Robust facial expression recognition based on median ternary pattern (MTP),
Electrical Information and Communication Technology (EICT), 2013 International Conference on,
IEEE, 2014, pp. 1-5.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.LTrP">
<dt class="sig sig-object py" id="lfepy.Descriptor.LTrP.LTrP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.LTrP.</span></span><span class="sig-name descname"><span class="pre">LTrP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.LTrP.LTrP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Local Transitional Pattern (LTrP) histograms and descriptors from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing LTrP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>LTrP_hist: Histogram(s) of LTrP descriptors.</p></li>
<li><p>imgDesc: LTrP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">LTrP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>T. Jabid, and O. Chae,
Local Transitional Pattern: A Robust Facial Image Descriptor for Automatic Facial Expression Recognition,Proc.
International Conference on Computer Convergence Technology,
Seoul, Korea, 2011, pp. 333-44.</p>
<p>T. Jabid, and O. Chae,
Facial Expression Recognition Based on Local Transitional Pattern.
International Information Institute (Tokyo).
Information 15 (2012) 2007.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.MBC">
<dt class="sig sig-object py" id="lfepy.Descriptor.MBC.MBC">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.MBC.</span></span><span class="sig-name descname"><span class="pre">MBC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.MBC.MBC" title="Link to this definition">¶</a></dt>
<dd><p>Compute Monogenic Binary Coding (MBC) histograms and descriptors from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing MBC extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
<li><p><strong>kwargs.mbcMode</strong> (<em>str</em>) -- Mode for MBC computation. Options: 'A' (amplitude), 'O' (orientation), 'P' (phase). Default: 'A'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>MBC_hist: Histogram of MBC descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing MBC descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">MBC</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">mbcMode</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>M. Yang, L. Zhang, S.C.-K. Shiu, and D. Zhang,
Monogenic binary coding: An efficient local feature extraction approach to face recognition.
IEEE Transactions on Information Forensics and Security 7 (2012) 1738-1751.</p>
<p>X.X. Xia, Z.L. Ying, and W.J. Chu,
Facial Expression Recognition Based on Monogenic Binary Coding,
Applied Mechanics and Materials,
Trans Tech Publ, 2014, pp. 437-440.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.MBP">
<dt class="sig sig-object py" id="lfepy.Descriptor.MBP.MBP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.MBP.</span></span><span class="sig-name descname"><span class="pre">MBP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.MBP.MBP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Median Binary Pattern (MBP) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing MBP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>MBP_hist: Histogram(s) of MBP descriptors.</p></li>
<li><p>imgDesc: MBP descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, numpy.ndarray)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">MBP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>F. Bashar, A. Khan, F. Ahmed, and M.H. Kabir,
Robust facial expression recognition based on median ternary pattern (MTP),
Electrical Information and Communication Technology (EICT), 2013 International Conference on,
IEEE, 2014, pp. 1-5.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.MRELBP">
<dt class="sig sig-object py" id="lfepy.Descriptor.MRELBP.MRELBP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.MRELBP.</span></span><span class="sig-name descname"><span class="pre">MRELBP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.MRELBP.MRELBP" title="Link to this definition">¶</a></dt>
<dd><p>Compute the Median Robust Extended Local Binary Pattern (MRELBP) descriptors and histogram from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing MRELBP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>MRELBP_hist: Histogram(s) of MRELBP descriptors.</p></li>
<li><dl class="simple">
<dt>imgDesc: A list of dictionaries where each dictionary contains the LBP descriptors for different radii. Each dictionary has:</dt><dd><ul>
<li><dl class="simple">
<dt>'fea': Features extracted for the specific radius, including:</dt><dd><ul>
<li><p>'CImg': Processed image data after median filtering and LBP transformation.</p></li>
<li><p>'NILBPImage': Histogram of the No-Interpolation LBP image.</p></li>
<li><p>'RDLBPImage': Histogram of the Refined Descriptors LBP image.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list of dicts)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">MRELBP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">][</span><span class="s1">&#39;NILBPImage&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">][</span><span class="s1">&#39;RDLBPImage&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>L. Liu, S. Lao, P.W. Fieguth, Y. Guo, X. Wang, and M. Pietikäinen,
Median robust extended local binary pattern for texture classification.
IEEE Transactions on Image Processing 25 (2016) 1368-1381.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.MTP">
<dt class="sig sig-object py" id="lfepy.Descriptor.MTP.MTP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.MTP.</span></span><span class="sig-name descname"><span class="pre">MTP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.MTP.MTP" title="Link to this definition">¶</a></dt>
<dd><p>Compute Median Ternary Pattern (MTP) descriptors and histograms from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing MTP extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
<li><p><strong>kwargs.t</strong> (<em>float</em>) -- Threshold value for MTP computation. Default: 10.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>MTP_hist: Histogram(s) of MTP descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing MTP descriptors for positive and negative thresholds.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list of dicts)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">MTP</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>F. Bashar, A. Khan, F. Ahmed, and M.H. Kabir,
Robust facial expression recognition based on median ternary pattern (MTP),
Electrical Information and Communication Technology (EICT), 2013 International Conference on,
IEEE, 2014, pp. 1-5.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.PHOG">
<dt class="sig sig-object py" id="lfepy.Descriptor.PHOG.PHOG">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.PHOG.</span></span><span class="sig-name descname"><span class="pre">PHOG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.PHOG.PHOG" title="Link to this definition">¶</a></dt>
<dd><p>Compute Pyramid Histogram of Oriented Gradients (PHOG) histograms and descriptors from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing PHOG extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
<li><p><strong>kwargs.bin</strong> (<em>int</em>) -- Number of bins for the histogram. Default: 8.</p></li>
<li><p><strong>kwargs.angle</strong> (<em>int</em>) -- Range of gradient angles. Default: 360.</p></li>
<li><p><strong>kwargs.L</strong> (<em>int</em>) -- Number of pyramid levels. Default: 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>PHOG_hist: Histogram of PHOG descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing PHOG descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list of dicts)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">PHOG</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="nb">bin</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">360</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>A. Bosch, A. Zisserman, and X. Munoz,
Representing shape with a spatial pyramid kernel,
Proceedings of the 6th ACM international conference on Image and video retrieval,
ACM, 2007, pp. 401-408.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Descriptor.WLD">
<dt class="sig sig-object py" id="lfepy.Descriptor.WLD.WLD">
<span class="sig-prename descclassname"><span class="pre">lfepy.Descriptor.WLD.</span></span><span class="sig-name descname"><span class="pre">WLD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Descriptor.WLD.WLD" title="Link to this definition">¶</a></dt>
<dd><p>Compute Weber Local Descriptor (WLD) histograms and descriptors from an input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image (preferably in NumPy array format).</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) -- Additional keyword arguments for customizing WLD extraction.</p></li>
<li><p><strong>kwargs.mode</strong> (<em>str</em>) -- Mode for histogram computation. Options: 'nh' (normalized histogram) or 'h' (histogram). Default: 'nh'.</p></li>
<li><p><strong>kwargs.T</strong> (<em>int</em>) -- Number of bins for gradient orientation. Default: 8.</p></li>
<li><p><strong>kwargs.N</strong> (<em>int</em>) -- Number of bins for differential excitation. Default: 4.</p></li>
<li><p><strong>kwargs.scaleTop</strong> (<em>int</em>) -- Number of scales to consider for WLD computation. Default: 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>WLD_hist: Histogram(s) of WLD descriptors.</p></li>
<li><p>imgDesc: List of dictionaries containing WLD descriptors.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of (numpy.ndarray, list of dicts)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">,</span> <span class="n">imgDesc</span> <span class="o">=</span> <span class="n">WLD</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">scaleTop</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">][</span><span class="s1">&#39;GO&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">imgDesc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;fea&#39;</span><span class="p">][</span><span class="s1">&#39;DE&#39;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">References<span class="colon">:</span></dt>
<dd class="field-odd"><p>S. Li, D. Gong, and Y. Yuan,
Face recognition using Weber local descriptors.
Neurocomputing 122 (2013) 272-283.</p>
<p>S. Liu, Y. Zhang, and K. Liu,
Facial expression recognition under partial occlusion based on Weber Local Descriptor histogram and decision fusion,
Control Conference (CCC), 2014 33rd Chinese,
IEEE, 2014, pp. 4664-4668.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-lfepy.Helper.helper">
<dt class="sig sig-object py" id="lfepy.Helper.helper.NILBP_Image_ct">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">NILBP_Image_ct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbpPoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbpRadius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.NILBP_Image_ct" title="Link to this definition">¶</a></dt>
<dd><p>Compute the Neighborhood Binary Pattern (NILBP) descriptor for an image using circular interpolation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>numpy.ndarray</em>) -- 2D grayscale image.</p></li>
<li><p><strong>lbpPoints</strong> (<em>int</em>) -- Number of points used in the LBP pattern.</p></li>
<li><p><strong>mapping</strong> (<em>dict</em><em> or </em><em>None</em>) -- A dictionary containing 'num' (number of bins) and 'table' (mapping table). If None, no mapping is applied.</p></li>
<li><p><strong>mode</strong> (<em>str</em>) -- Mode for output. 'h' or 'hist' for histogram of the NILBP, 'nh' for normalized histogram.</p></li>
<li><p><strong>lbpRadius</strong> (<em>int</em>) -- Radius of the circular neighborhood for computing LBP.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>NILBP descriptor, either as a histogram or image depending on the <cite>mode</cite> parameter.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lbpPoints</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lbpRadius</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;num&#39;</span><span class="p">:</span> <span class="mi">256</span><span class="p">,</span> <span class="s1">&#39;table&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">256</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">NILBP_Image_ct</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">lbpPoints</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="n">lbpRadius</span><span class="o">=</span><span class="n">lbpRadius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">descriptor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(256,)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.NewRDLBP_Image">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">NewRDLBP_Image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imgPre</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbpRadius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbpRadiusPre</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbpPoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'h'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.NewRDLBP_Image" title="Link to this definition">¶</a></dt>
<dd><p>Compute the Radial Difference Local Binary Pattern (RDLBP) between two images.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>numpy.ndarray</em>) -- 2D grayscale image.</p></li>
<li><p><strong>imgPre</strong> (<em>numpy.ndarray</em>) -- 2D grayscale image for comparison.</p></li>
<li><p><strong>lbpRadius</strong> (<em>int</em>) -- Radius of the circular neighborhood for the current image.</p></li>
<li><p><strong>lbpRadiusPre</strong> (<em>int</em>) -- Radius of the circular neighborhood for the comparison image.</p></li>
<li><p><strong>lbpPoints</strong> (<em>int</em>) -- Number of points used in the LBP pattern.</p></li>
<li><p><strong>mapping</strong> (<em>dict</em><em> or </em><em>None</em><em>, </em><em>optional</em>) -- Mapping dictionary for converting the LBP result to a different bin scheme.
If provided, must contain 'num' (number of bins) and 'table' (mapping from old bin to new bin).</p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) -- Mode for output. 'h' or 'hist' for histogram of the RDLBP, 'nh' for normalized histogram. Default is 'h'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>RDLBP descriptor, either as a histogram or image depending on the <cite>mode</cite> parameter.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgPre</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lbpRadius</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lbpRadiusPre</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lbpPoints</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span> <span class="o">=</span> <span class="n">NewRDLBP_Image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">imgPre</span><span class="p">,</span> <span class="n">lbpRadius</span><span class="p">,</span> <span class="n">lbpRadiusPre</span><span class="p">,</span> <span class="n">lbpPoints</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">hist</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(256,)  # Example output shape for normalized histogram</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.RDLBP_Image_SmallestRadiusOnly">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">RDLBP_Image_SmallestRadiusOnly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imgCenSmooth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbpRadius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbpPoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.RDLBP_Image_SmallestRadiusOnly" title="Link to this definition">¶</a></dt>
<dd><p>Compute the Radial Difference Local Binary Pattern (RDLBP) for an image with a focus on the smallest radius.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imgCenSmooth</strong> (<em>numpy.ndarray</em>) -- Smoothed image from which the radial difference is computed.</p></li>
<li><p><strong>img</strong> (<em>numpy.ndarray</em>) -- Original image for extracting circularly interpolated blocks.</p></li>
<li><p><strong>lbpRadius</strong> (<em>int</em>) -- Radius of the circular neighborhood for LBP.</p></li>
<li><p><strong>lbpPoints</strong> (<em>int</em>) -- Number of points used in the LBP pattern.</p></li>
<li><p><strong>mapping</strong> (<em>dict</em><em> or </em><em>None</em>) -- Optional mapping dictionary for converting LBP result to a different bin scheme.
Must contain 'num' (number of bins) and 'table' (mapping from old bin to new bin).</p></li>
<li><p><strong>mode</strong> (<em>str</em>) -- Output mode. 'h' or 'hist' for histogram of the RDLBP, 'nh' for normalized histogram.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>RDLBP descriptor, either as a histogram or image depending on the <cite>mode</cite> parameter.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgCenSmooth</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lbpRadius</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lbpPoints</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;num&#39;</span><span class="p">:</span> <span class="mi">256</span><span class="p">,</span> <span class="s1">&#39;table&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">256</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span> <span class="o">=</span> <span class="n">RDLBP_Image_SmallestRadiusOnly</span><span class="p">(</span><span class="n">imgCenSmooth</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">lbpRadius</span><span class="p">,</span> <span class="n">lbpPoints</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">hist</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(256,)  # Example output shape for normalized histogram</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.bin_matrix">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">bin_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.bin_matrix" title="Link to this definition">¶</a></dt>
<dd><p>Compute the bin matrix for a given angle map and gradient magnitude.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em>) -- Angle map of the gradient directions.</p></li>
<li><p><strong>E</strong> (<em>numpy.ndarray</em>) -- Binary edge map where edges are marked.</p></li>
<li><p><strong>G</strong> (<em>numpy.ndarray</em>) -- Gradient magnitude map.</p></li>
<li><p><strong>angle</strong> (<em>float</em>) -- Total range of angles in degrees (e.g., 360 for full circle).</p></li>
<li><p><strong>bin</strong> (<em>int</em>) -- Number of bins to divide the angle range into.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>bm: Bin matrix with assigned bins for each pixel.</p></li>
<li><p>bv: Gradient magnitude values corresponding to the bin matrix.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>bm: numpy.ndarray</p></li>
<li><p>bv: numpy.ndarray</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">135</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angle</span> <span class="o">=</span> <span class="mi">360</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bm</span><span class="p">,</span> <span class="n">bv</span> <span class="o">=</span> <span class="n">bin_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="nb">bin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bm</span><span class="p">)</span>
<span class="go">[[1 2]</span>
<span class="go"> [3 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bv</span><span class="p">)</span>
<span class="go">[[1. 2.]</span>
<span class="go"> [3. 4.]]</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.cirInterpSingleRadiusNew">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">cirInterpSingleRadiusNew</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbpPoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbpRadius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.cirInterpSingleRadiusNew" title="Link to this definition">¶</a></dt>
<dd><p>Extract circularly interpolated image blocks around a specified radius and number of points.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>numpy.ndarray</em>) -- The input grayscale image.</p></li>
<li><p><strong>lbpPoints</strong> (<em>int</em>) -- The number of points used in the LBP pattern.</p></li>
<li><p><strong>lbpRadius</strong> (<em>int</em>) -- The radius of the circular neighborhood.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>blocks: A 2D array where each row represents a circularly interpolated block.</p></li>
<li><p>dx: The width of the output blocks.</p></li>
<li><p>dy: The height of the output blocks.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple (numpy.ndarray, int, int)</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lbpPoints</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lbpRadius</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blocks</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">cirInterpSingleRadiusNew</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">lbpPoints</span><span class="p">,</span> <span class="n">lbpRadius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.cirInterpSingleRadius_ct">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">cirInterpSingleRadius_ct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbpPoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbpRadius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.cirInterpSingleRadius_ct" title="Link to this definition">¶</a></dt>
<dd><p>Perform circular interpolation for a single radius in the LBP (Local Binary Pattern) computation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<em>numpy.ndarray</em>) -- 2D grayscale image.</p></li>
<li><p><strong>lbpPoints</strong> (<em>int</em>) -- Number of points used in the LBP pattern.</p></li>
<li><p><strong>lbpRadius</strong> (<em>int</em>) -- Radius of the circular neighborhood for computing LBP.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>blocks (numpy.ndarray): Array of size (lbpPoints, imgNewH * imgNewW) containing the interpolated pixel values.</p></li>
<li><p>dx (int): Width of the output blocks.</p></li>
<li><p>dy (int): Height of the output blocks.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>  <span class="c1"># Example grayscale image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lbpPoints</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lbpRadius</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blocks</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">cirInterpSingleRadius_ct</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">lbpPoints</span><span class="p">,</span> <span class="n">lbpRadius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Shape of the blocks array</span>
<span class="go">(8, 9216)  # Example output shape</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.construct_Gabor_filters">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">construct_Gabor_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_of_orient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_of_scales</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ni</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.construct_Gabor_filters" title="Link to this definition">¶</a></dt>
<dd><p>Constructs a bank of Gabor filters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_of_orient</strong> (<em>int</em>) -- Number of orientations.</p></li>
<li><p><strong>num_of_scales</strong> (<em>int</em>) -- Number of scales.</p></li>
<li><p><strong>size1</strong> (<em>int</em><em> or </em><em>tuple</em>) -- Size of the filters. Can be an integer for square filters or a tuple for rectangular filters.</p></li>
<li><p><strong>fmax</strong> (<em>float</em><em>, </em><em>optional</em>) -- Maximum frequency. Default is 0.25.</p></li>
<li><p><strong>ni</strong> (<em>float</em><em>, </em><em>optional</em>) -- Bandwidth parameter. Default is sqrt(2).</p></li>
<li><p><strong>gamma</strong> (<em>float</em><em>, </em><em>optional</em>) -- Aspect ratio. Default is sqrt(2).</p></li>
<li><p><strong>separation</strong> (<em>float</em><em>, </em><em>optional</em>) -- Frequency separation factor. Default is sqrt(2).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary containing the spatial and frequency representations of the Gabor filters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_of_orient</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_of_scales</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filter_size</span> <span class="o">=</span> <span class="mi">31</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gabor_filters</span> <span class="o">=</span> <span class="n">construct_Gabor_filters</span><span class="p">(</span><span class="n">num_of_orient</span><span class="p">,</span> <span class="n">num_of_scales</span><span class="p">,</span> <span class="n">filter_size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">num_of_scales</span><span class="p">,</span> <span class="n">num_of_orient</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_of_scales</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_of_orient</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>
<span class="gp">... </span>        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">gabor_filters</span><span class="p">[</span><span class="s1">&#39;spatial&#39;</span><span class="p">][</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.descriptor_LBP">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">descriptor_LBP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">varargin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.descriptor_LBP" title="Link to this definition">¶</a></dt>
<dd><p>Compute the Local Binary Pattern (LBP) of an image with various options for radius, neighbors, mapping, and mode.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- The input image.</p></li>
<li><p><strong>radius</strong> (<em>int</em>) -- The radius of the LBP.</p></li>
<li><p><strong>neighbors</strong> (<em>int</em>) -- The number of sampling points in the LBP.</p></li>
<li><p><strong>mapping</strong> (<em>dict</em><em> or </em><em>None</em>) -- The mapping information.</p></li>
<li><p><strong>mode</strong> (<em>str</em>) -- The mode for LBP calculation. Options are 'h' (histogram), 'hist' (histogram), or 'nh' (normalized histogram).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing:
- result: The LBP histogram or LBP image.
- codeImage: The LBP code image.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> -- If the number of input arguments is incorrect or other validation fails.</p>
</dd>
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="p">,</span> <span class="n">codeImage</span> <span class="o">=</span> <span class="n">compute_lbp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;nh&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.descriptor_LDN">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">descriptor_LDN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.descriptor_LDN" title="Link to this definition">¶</a></dt>
<dd><p>Compute the Local Descriptor using Kirsch or Gaussian masks.
This function computes a local descriptor for an input image using different masks
based on the specified options. The masks include Kirsch masks for various sizes
or a Gaussian gradient mask. The size of the mask can be adjusted through the
<cite>msize</cite> parameter, and the <cite>sigma</cite> parameter controls the standard deviation for
the Gaussian mask.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- The input image for which the descriptor is computed.</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) -- Additional optional parameters to customize the mask:
- 'mask' (str): Type of mask to use. Options are 'kirsch' (default) or 'gaussian'.
- 'msize' (int): Size of the Kirsch mask. Options are 3, 5, 7, 9, or 11 (default is 3).
- 'sigma' (float): Standard deviation for the Gaussian mask (default is 0.5).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The local descriptor matrix computed using the specified mask.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> -- If an invalid mask type or size is provided.</p>
</dd>
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">descriptor_LDN</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="s1">&#39;kirsch&#39;</span><span class="p">,</span> <span class="n">msize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">descriptor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.descriptor_LPQ">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">descriptor_LPQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winSize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decorr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freqestim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'im'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.descriptor_LPQ" title="Link to this definition">¶</a></dt>
<dd><p>Compute the Local Phase Quantization (LPQ) descriptor for a given grayscale image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Grayscale input image.</p></li>
<li><p><strong>winSize</strong> (<em>int</em>) -- Size of the window used for LPQ calculation (must be an odd number ≥ 3). Default is 3.</p></li>
<li><p><strong>decorr</strong> (<em>int</em>) -- Flag to apply decorrelation. 0 for no decorrelation, 1 for decorrelation. Default is 1.</p></li>
<li><p><strong>freqestim</strong> (<em>int</em>) -- Frequency estimation method. 1 for STFT uniform window, 2 for STFT Gaussian window, 3 for Gaussian derivative quadrature filter pair. Default is 1.</p></li>
<li><p><strong>mode</strong> (<em>str</em>) -- Specifies the output format. 'im' for image-like output, 'nh' for normalized histogram, 'h' for histogram. Default is 'im'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing:
- LPQdesc: The LPQ descriptor of the image. Depending on <cite>mode</cite>, it could be an image or a histogram.
- freqRespAll: The frequency responses for all filter pairs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple
- LPQdesc (numpy.ndarray): Descriptor image or histogram.
- freqRespAll (numpy.ndarray): Frequency responses.</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">desc</span><span class="p">,</span> <span class="n">freq_resp</span> <span class="o">=</span> <span class="n">descriptor_LPQ</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">winSize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">decorr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freqestim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">desc</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(256,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">freq_resp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(100, 100, 8)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.descriptor_PHOG">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">descriptor_PHOG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">360</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.descriptor_PHOG" title="Link to this definition">¶</a></dt>
<dd><p>Compute the Pyramid Histogram of Oriented Gradients (PHOG) descriptor for a 2D image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input image, which can be grayscale or RGB.</p></li>
<li><p><strong>bin</strong> (<em>int</em><em>, </em><em>optional</em>) -- Number of orientation bins for the histogram. Default is 8.</p></li>
<li><p><strong>angle</strong> (<em>int</em><em>, </em><em>optional</em>) -- Angle range for orientation. Can be 180 or 360 degrees. Default is 360.</p></li>
<li><p><strong>L</strong> (<em>int</em><em>, </em><em>optional</em>) -- Number of pyramid levels. Default is 2.</p></li>
<li><p><strong>roi</strong> (<em>list</em><em> or </em><em>None</em><em>, </em><em>optional</em>) -- Region of Interest (ROI) as [y_min, y_max, x_min, x_max]. If None, the entire image is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>p_hist: List of histograms for each pyramid level.</p></li>
<li><p>bh_roi: Gradient magnitude matrix for the ROI.</p></li>
<li><p>bv_roi: Gradient orientation matrix for the ROI.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>p_hist: list</p></li>
<li><p>bh_roi: numpy.ndarray</p></li>
<li><p>bv_roi: numpy.ndarray</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>  <span class="c1"># Example grayscale image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_hist</span><span class="p">,</span> <span class="n">bh_roi</span><span class="p">,</span> <span class="n">bv_roi</span> <span class="o">=</span> <span class="n">descriptor_PHOG</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">bin</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">360</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p_hist</span><span class="p">))</span>  <span class="c1"># Number of levels in the PHOG descriptor</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bh_roi</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Shape of the gradient magnitude matrix for the ROI</span>
<span class="go">(480, 640)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bv_roi</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Shape of the gradient orientation matrix for the ROI</span>
<span class="go">(480, 640)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.dgauss">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">dgauss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.dgauss" title="Link to this definition">¶</a></dt>
<dd><p>Compute the derivative of the Gaussian (normal) distribution with respect to x.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float</em><em> or </em><em>numpy.ndarray</em>) -- The point or points at which to evaluate the derivative.</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) -- The standard deviation of the Gaussian distribution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The derivative of the Gaussian function at the given point(s).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float or numpy.ndarray</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dgauss</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">-0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dgauss</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([-0., -0.24197072, -0.10798193])</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.filter_image_with_Gabor_bank">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">filter_image_with_Gabor_bank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_bank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">down_sampling_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.filter_image_with_Gabor_bank" title="Link to this definition">¶</a></dt>
<dd><p>Apply a Gabor filter bank to an image and return the filtered features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>np.ndarray</em>) -- Input image to be filtered. Should be a 2D numpy array.</p></li>
<li><p><strong>filter_bank</strong> (<em>dict</em>) -- Dictionary containing Gabor filter bank with 'spatial' and 'freq' keys.</p></li>
<li><p><strong>down_sampling_factor</strong> (<em>int</em><em>, </em><em>optional</em>) -- Factor for down-sampling the filtered images. Default is 64.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Concatenated filtered features from the Gabor filter bank.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> -- If the inputs are not as expected or dimensions do not match.</p>
</dd>
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filter_bank</span> <span class="o">=</span> <span class="n">construct_Gabor_filters</span><span class="p">(</span><span class="n">num_of_orient</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">num_of_scales</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">size1</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">features</span> <span class="o">=</span> <span class="n">filter_image_with_Gabor_bank</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">filter_bank</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">features</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.gabor_filter">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">gabor_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orienNum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaleNum</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.gabor_filter" title="Link to this definition">¶</a></dt>
<dd><p>Apply a Gabor filter bank to an image and organize the results into a multidimensional array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>np.ndarray</em>) -- Input image to be filtered. Should be a 2D numpy array.</p></li>
<li><p><strong>orienNum</strong> (<em>int</em>) -- Number of orientation filters in the Gabor filter bank.</p></li>
<li><p><strong>scaleNum</strong> (<em>int</em>) -- Number of scale filters in the Gabor filter bank.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Multidimensional array containing the Gabor magnitude responses. Shape is (height, width, orienNum, scaleNum).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gabor_magnitudes</span> <span class="o">=</span> <span class="n">gabor_filter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">orienNum</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">scaleNum</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gabor_magnitudes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(512, 512, 8, 5)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.gauss">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">gauss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.gauss" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the value of the Gaussian (normal) distribution at a given point.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float</em><em> or </em><em>numpy.ndarray</em>) -- The point or points at which to evaluate the Gaussian function.</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) -- The standard deviation of the Gaussian distribution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value(s) of the Gaussian function at the given point(s).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float or numpy.ndarray</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gauss</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0.3989422804014327</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gauss</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([0.39894228, 0.24197072, 0.05399097])</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.gauss_gradient">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">gauss_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.gauss_gradient" title="Link to this definition">¶</a></dt>
<dd><p>Generate a set of 2-D Gaussian derivative kernels for gradient computation at multiple orientations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sigma</strong> (<em>float</em>) -- The standard deviation of the Gaussian distribution.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 3D array where each 2D slice represents a Gaussian derivative kernel at a specific orientation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernels</span> <span class="o">=</span> <span class="n">gauss_gradient</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">kernels</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="o">*</span><span class="mi">45</span><span class="si">}</span><span class="s1"> degrees&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.get_mapping">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">get_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mappingtype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.get_mapping" title="Link to this definition">¶</a></dt>
<dd><p>Generate a mapping table for Local Binary Patterns (LBP) codes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>samples</strong> (<em>int</em>) -- The number of sampling points in the LBP.</p></li>
<li><p><strong>mappingtype</strong> (<em>str</em>) -- The type of LBP mapping ('u2', 'ri', 'riu2').</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary with the following keys:</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>'table': The mapping table.</p></li>
<li><p>'samples': The number of sampling points.</p></li>
<li><p>'num': The number of patterns in the resulting LBP code.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> -- If an unsupported mapping type is provided.</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_mapping</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;u2&#39;</span><span class="p">)</span>
<span class="go">{&#39;table&#39;: array([...]), &#39;samples&#39;: 8, &#39;num&#39;: 59}</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.get_mapping_info_ct">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">get_mapping_info_ct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lbp_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbp_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbp_method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.get_mapping_info_ct" title="Link to this definition">¶</a></dt>
<dd><p>Retrieve or generate a mapping for circular (center-symmetric) LBP.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lbp_radius</strong> (<em>int</em>) -- The radius of the LBP.</p></li>
<li><p><strong>lbp_points</strong> (<em>int</em>) -- The number of sampling points in the LBP.</p></li>
<li><p><strong>lbp_method</strong> (<em>str</em>) -- The method for LBP mapping.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary with the mapping information.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>'table': The mapping table.</p></li>
<li><p>'samples': The number of sampling points.</p></li>
<li><p>'num': The number of patterns in the resulting LBP code.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_mapping_info_ct</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="s1">&#39;LBPriu2&#39;</span><span class="p">)</span>
<span class="go">{&#39;table&#39;: array([...]), &#39;samples&#39;: 24, &#39;num&#39;: 26}</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.get_mapping_mrelbp">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">get_mapping_mrelbp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mappingtype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.get_mapping_mrelbp" title="Link to this definition">¶</a></dt>
<dd><p>Generate a mapping table for Modified Rotation and Uniform Local Binary Patterns (MRELBP) codes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>samples</strong> (<em>int</em>) -- The number of sampling points in the LBP.</p></li>
<li><p><strong>mappingtype</strong> (<em>str</em>) -- The type of LBP mapping, supporting various uniform, rotation invariant, and modified patterns.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary with the following keys:</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>'table': The mapping table.</p></li>
<li><p>'samples': The number of sampling points.</p></li>
<li><p>'num': The number of patterns in the resulting LBP code.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_mapping_mrelbp</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;u2&#39;</span><span class="p">)</span>
<span class="go">{&#39;table&#39;: array([...]), &#39;samples&#39;: 8, &#39;num&#39;: 59}</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.low_pass_filter">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">low_pass_filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.low_pass_filter" title="Link to this definition">¶</a></dt>
<dd><p>Creates a low-pass Butterworth filter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>tuple</em><em> of </em><em>int</em>) -- The size of the filter. If a single integer is provided, the filter will be square with that size.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) -- The cutoff frequency for the filter. Must be between 0 and 0.5.</p></li>
<li><p><strong>n</strong> (<em>int</em>) -- The order of the Butterworth filter. Must be an integer greater than or equal to 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The low-pass Butterworth filter in the frequency domain.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> -- If <cite>cutoff</cite> is not in the range [0, 0.5], or if <cite>n</cite> is not an integer greater than or equal to 1.</p>
</dd>
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filter_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cutoff_frequency</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">order</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lp_filter</span> <span class="o">=</span> <span class="n">low_pass_filter</span><span class="p">(</span><span class="n">filter_size</span><span class="p">,</span> <span class="n">cutoff_frequency</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">lp_filter</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(256, 256)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.lxp_phase">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">lxp_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'h'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.lxp_phase" title="Link to this definition">¶</a></dt>
<dd><p>Compute the Local X-Y Pattern (LXP) descriptor for a 2D grayscale image based on local phase information.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- 2D grayscale image.</p></li>
<li><p><strong>radius</strong> (<em>int</em><em>, </em><em>optional</em>) -- Radius of the circular neighborhood for computing the pattern. Default is 1.</p></li>
<li><p><strong>neighbors</strong> (<em>int</em><em>, </em><em>optional</em>) -- Number of directions or neighbors to consider. Default is 8.</p></li>
<li><p><strong>mapping</strong> (<em>numpy.ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) -- Coordinates of neighbors relative to each pixel. If None, uses a default circular pattern. If a single digit, computes neighbors in a circular pattern based on the digit. Default is None.</p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) -- Mode for output. 'h' or 'hist' for histogram of the LXP, 'nh' for normalized histogram. Default is 'h'.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>LXP descriptor, either as a histogram or image depending on the <cite>mode</cite> parameter.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lxp_desc</span> <span class="o">=</span> <span class="n">lxp_phase</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">lxp_desc</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(256,)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.monofilt">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">monofilt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nscale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minWaveLength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mult</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmaOnf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientWrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thetaPhase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.monofilt" title="Link to this definition">¶</a></dt>
<dd><p>Apply a multiscale directional filter bank to a 2D grayscale image using Log-Gabor filters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> (<em>numpy.ndarray</em>) -- 2D grayscale image.</p></li>
<li><p><strong>nscale</strong> (<em>int</em>) -- Number of scales in the filter bank.</p></li>
<li><p><strong>minWaveLength</strong> (<em>float</em>) -- Minimum wavelength of the filters.</p></li>
<li><p><strong>mult</strong> (<em>float</em>) -- Scaling factor between consecutive scales.</p></li>
<li><p><strong>sigmaOnf</strong> (<em>float</em>) -- Bandwidth of the Log-Gabor filter.</p></li>
<li><p><strong>orientWrap</strong> (<em>int</em><em>, </em><em>optional</em>) -- If 1, wrap orientations to the range [0, π]. Default is 0 (no wrapping).</p></li>
<li><p><strong>thetaPhase</strong> (<em>int</em><em>, </em><em>optional</em>) -- If 1, compute phase angles (theta and psi). Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing:
- f: Filter responses in the spatial domain.
- h1f: x-direction filter responses in the spatial domain.
- h2f: y-direction filter responses in the spatial domain.
- A: Amplitude of the filter responses.
- theta: Phase angle of the filter responses, if <cite>thetaPhase</cite> is 1.
- psi: Orientation angle of the filter responses, if <cite>thetaPhase</cite> is 1.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple
- f (list of numpy.ndarray): Filter responses.
- h1f (list of numpy.ndarray): x-direction filter responses.
- h2f (list of numpy.ndarray): y-direction filter responses.
- A (list of numpy.ndarray): Amplitude responses.
- theta (list of numpy.ndarray, optional): Phase angles.
- psi (list of numpy.ndarray, optional): Orientation angles.</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nscale</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minWaveLength</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaOnf</span> <span class="o">=</span> <span class="mf">0.55</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">h1f</span><span class="p">,</span> <span class="n">h2f</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">monofilt</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">nscale</span><span class="p">,</span> <span class="n">minWaveLength</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">sigmaOnf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Shape of the response for the first scale</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.phase_cong3">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">phase_cong3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minWaveLength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mult</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmaOnf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.55</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dThetaOnSigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutOff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.phase_cong3" title="Link to this definition">¶</a></dt>
<dd><p>Computes the phase congruency of an image using a multiscale, multi-orientation approach.
Phase congruency is a measure of the image's local contrast, based on the phase information of its frequency components.
This method is used for edge detection and texture analysis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>numpy.ndarray</em>) -- Input grayscale image as a 2D numpy array.</p></li>
<li><p><strong>nscale</strong> (<em>int</em><em>, </em><em>optional</em>) -- Number of scales to be used in the analysis (default is 4).</p></li>
<li><p><strong>norient</strong> (<em>int</em><em>, </em><em>optional</em>) -- Number of orientations to be used in the analysis (default is 6).</p></li>
<li><p><strong>minWaveLength</strong> (<em>float</em><em>, </em><em>optional</em>) -- Minimum wavelength of the log-Gabor filters (default is 3).</p></li>
<li><p><strong>mult</strong> (<em>float</em><em>, </em><em>optional</em>) -- Scaling factor for the wavelength of the log-Gabor filters (default is 2.1).</p></li>
<li><p><strong>sigmaOnf</strong> (<em>float</em><em>, </em><em>optional</em>) -- Standard deviation of the Gaussian function used in the log-Gabor filter (default is 0.55).</p></li>
<li><p><strong>dThetaOnSigma</strong> (<em>float</em><em>, </em><em>optional</em>) -- Angular spread of the Gaussian function relative to the orientation (default is 1.5).</p></li>
<li><p><strong>k</strong> (<em>float</em><em>, </em><em>optional</em>) -- Constant to adjust the threshold for noise (default is 2.0).</p></li>
<li><p><strong>cutOff</strong> (<em>float</em><em>, </em><em>optional</em>) -- Cut-off parameter for weighting function (default is 0.5).</p></li>
<li><p><strong>g</strong> (<em>float</em><em>, </em><em>optional</em>) -- Gain parameter for the weighting function (default is 10).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing:
- M: The measure of local phase congruency.
- m: The measure of local phase concavity.
- ori: Orientation of the phase congruency.
- featType: Feature type (complex representation of phase congruency).
- PC: List of phase congruency maps for each orientation.
- EO: List of complex responses for each scale and orientation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of numpy.ndarray and list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> -- If the input image is not a 2D numpy array.</p>
</dd>
<dt class="field-odd">Notes<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p>The function assumes the input image is grayscale.</p></li>
<li><p>The log-Gabor filters are used to analyze the image at different scales and orientations.</p></li>
<li><p>The phase congruency is computed based on the response of these filters, and noise is estimated and thresholded.</p></li>
<li><p>The result includes orientation information, which can be useful for edge detection and texture analysis.</p></li>
</ul>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">ori</span><span class="p">,</span> <span class="n">featType</span><span class="p">,</span> <span class="n">PC</span><span class="p">,</span> <span class="n">EO</span> <span class="o">=</span> <span class="n">phase_cong3</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.phogDescriptor_hist">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">phogDescriptor_hist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.phogDescriptor_hist" title="Link to this definition">¶</a></dt>
<dd><p>Compute the histogram of the Pyramid Histogram of Oriented Gradients (PHOG) descriptor.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bh</strong> (<em>numpy.ndarray</em>) -- Bin matrix of the image, where each pixel is assigned a bin index.</p></li>
<li><p><strong>bv</strong> (<em>numpy.ndarray</em>) -- Gradient magnitude matrix corresponding to the bin matrix.</p></li>
<li><p><strong>L</strong> (<em>int</em>) -- Number of pyramid levels.</p></li>
<li><p><strong>bin</strong> (<em>int</em>) -- Number of bins for the histogram.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Normalized histogram of the PHOG descriptor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phog_hist</span> <span class="o">=</span> <span class="n">phogDescriptor_hist</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">bv</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="nb">bin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">phog_hist</span><span class="p">)</span>
<span class="go">[0.1 0.2 0.2 0.1 0.1 0.1 0.1 0.1]</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.roundn">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">roundn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.roundn" title="Link to this definition">¶</a></dt>
<dd><p>Round a number to a specified number of decimal places.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float</em><em> or </em><em>array-like</em>) -- The number or array of numbers to be rounded.</p></li>
<li><p><strong>n</strong> (<em>int</em>) -- The number of decimal places to round to. If <cite>n</cite> is negative, <cite>x</cite> is rounded to the left of the decimal point. If <cite>n</cite> is zero, <cite>x</cite> is rounded to the nearest integer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The rounded number or array of numbers.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float or array-like</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">roundn</span><span class="p">(</span><span class="mf">123.456</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">123.46</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roundn</span><span class="p">(</span><span class="mf">123.456</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">120.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roundn</span><span class="p">(</span><span class="mf">123.456</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">123.0</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lfepy.Helper.helper.view_as_windows">
<span class="sig-prename descclassname"><span class="pre">lfepy.Helper.helper.</span></span><span class="sig-name descname"><span class="pre">view_as_windows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lfepy.Helper.helper.view_as_windows" title="Link to this definition">¶</a></dt>
<dd><p>Create a view of an array with sliding windows.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>numpy.ndarray</em>) -- The input array.</p></li>
<li><p><strong>window_shape</strong> (<em>tuple</em>) -- Shape of the sliding window.</p></li>
<li><p><strong>step</strong> (<em>int</em><em> or </em><em>tuple</em>) -- Step size of the sliding window.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A view of the array with sliding windows.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> -- If any dimension of the window shape is larger than the corresponding dimension of the array.</p>
</dd>
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">view_as_windows</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="n">window_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">lfepy</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Prof. Dr. Khalid M. Hosny, B.Sc. Mahmoud A. Mohamed.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.0.2</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>